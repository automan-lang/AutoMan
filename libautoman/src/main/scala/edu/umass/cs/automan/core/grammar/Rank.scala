package edu.umass.cs.automan.core.grammar

import scala.collection.mutable.ArrayBuffer
import edu.umass.cs.automan.core.grammar.Expand.{KCount, Start, binding, ch, expand, nt, prettyPrint, ref, seq, term}

object Rank {

  //val Start = new Name("Start", None)

  //type Name = (String, Option[Int]) // Names are Strings associated with depth k
  type Grammar = Map[Name, Expression] // Maps Strings (Expression Ref names) to Expressions

  /**
    * Generates the base array for a given Grammar.
    * @param g The grammar to analyze
    * @return An array where each position represents a possible assignment of a value in the expression
    */
  def generateBases(g: Grammar): Array[Int] = {
    //generateBasesHelper(g(Start), g, Set[Name](), ArrayBuffer[Int]())._1.toArray
    generateBasesHelper(g(Start), g, Map[String, Int]())._1
  }

  //  def generateExprBases(expr: Expression, g: Grammar): Array[Int] = {
  //    //generateBasesHelper(expr, g, Set[Name](), ArrayBuffer[Int]())._1.toArray
  //  }

  // A helper method to generate bases for an Expression
  // Returns base array and updated KCount
  def generateBasesHelper(expr: Expression, g: Grammar, kc: KCount): (Array[Int], KCount) = {
    expr match {
      case Ref(nt) => generateBasesHelper(g(nt), g, kc) // forward
      case OptionProduction(text) => generateBasesHelper(text, g, kc) // forward
      case Terminal(value) => (Array[Int](), kc) // no base for Terms
      case Function(_,_,_) => (Array[Int](), kc) // no base for Functions
      case Sequence(sentence) => mergeHelper(sentence, kc, g) // generate bases for all exprs in Seq and combine
      case Choice(choices) => { // ditto
        val numChoices = choices.length
        val (bases, newKC) = mergeHelper(choices, kc, g)
        //(Array[Int](numChoices).concat(bases), newKC)
        (Array[Int](numChoices) ++ bases, newKC)
      }
      case Binding(nt) => { // generate base if 0th instance of binding
        val name = nt.text
        val depth = nt.depth
        depth match {
          case Some(i) => {
            assert(i == 0) // we should only ever retrieve a reference for the 0th binding
          }
          case None => { throw new Error("Expand grammars before generating bases")}
        }
        if(!(kc contains name)) { // if haven't seen before, generate base
          val newKC = kc + (name -> 1)
          generateBasesHelper(g(nt), g, newKC)
        } else { // otherwise carry on
          val newKC = kc + (name -> (kc(name) + 1))
          (Array[Int](), newKC)
        }
      }
    }
  }

  // Merges two arrays with updated KCount
  def mergeHelper(exprs: Array[Expression], kc: KCount, g: Grammar): (Array[Int], KCount) = {
    exprs.foldLeft((Array[Int](), kc)) {
      (acc, e) => {
        acc match {
          case (arr, kc) => {
            val (newArr, newKC) = generateBasesHelper(e, g, kc)
            //(newArr.concat(arr), newKC)
            (arr ++ newArr, newKC)
          } case _ => throw new Error("Something is wrong in merging")
        }
      }
    }
  }

  def count(expr: Expression): Int = {
    expr match {
      case Ref(nt) => throw new Error("no nested refs")
      case Binding(nt) => throw new Error("no nested bindings")
      case Sequence(sentence) => 1
      case Terminal(value) => 1
      case Choice(choices) => choices.length
    }
  }

  /**
    * Converts an instance of an Expression to a unique integer
    * @param assignments The value assignments for the instance
    * @param bases The bases for the Expression (generated by generateBases)
    * @return An integer between 0 and n, where n is the number of instances of the Expression - 1, representing the ranking
    */
  def rank(assignments: Array[Int], bases: Array[Int]): Int = {
    var toRet = 0
    for(i <- 0 to assignments.length - 1){
      toRet += assignments(i)*product(bases.slice(i+1,bases.length))
    }
    toRet
  }

  // A helper method to take the product of an array of ints
  private def product(l: Array[Int]): Int = {
    l.foldLeft(1)((a,b) => a*b)
  }

  /**
    * Converts an Expression ranking into an assignment array.
    * @param rank The rank of the Expression to be converted
    * @param bases The bases for the Expression (generated by generateBases)
    * @return An assignment for the given ranking
    */
  def unrank(rank: Int, bases: Array[Int]): Array[Int] = {
    var toRet: ArrayBuffer[Int] = new ArrayBuffer[Int]()
    for(i <- 0 to bases.length - 1){
      toRet += rank/product(bases.slice(i+1, bases.length))%bases(i)
    }
    toRet.toArray
  }
}
